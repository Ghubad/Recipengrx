{"remainingRequest":"/Users/u207640/Desktop/Angular/Recipengrx/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/u207640/Desktop/Angular/Recipengrx/node_modules/@ngrx/effects/fesm5/effects.js","dependencies":[{"path":"/Users/u207640/Desktop/Angular/Recipengrx/node_modules/@ngrx/effects/fesm5/effects.js","mtime":1533168748000},{"path":"/Users/u207640/Desktop/Angular/Recipengrx/node_modules/cache-loader/dist/cjs.js","mtime":1535104167000},{"path":"/Users/u207640/Desktop/Angular/Recipengrx/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * @license NgRx 6.1.0\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\n/** PURE_IMPORTS_START _ngrx_store,rxjs,rxjs_operators,_angular_core PURE_IMPORTS_END */\nimport { compose, ScannedActionsSubject, Store, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject } from 'rxjs';\nimport { ignoreElements, map, materialize, filter, dematerialize, exhaustMap, groupBy, mergeMap } from 'rxjs/operators';\nimport { Inject, Injectable, ErrorHandler, InjectionToken, NgModule, Optional } from '@angular/core';\nvar __values = (undefined && undefined.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m)\n        return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length)\n                o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar METADATA_KEY = '__@ngrx/effects__';\nfunction getEffectMetadataEntries(sourceProto) {\n    return sourceProto.constructor.hasOwnProperty(METADATA_KEY)\n        ? sourceProto.constructor[METADATA_KEY]\n        : [];\n}\nfunction setEffectMetadataEntries(sourceProto, entries) {\n    var constructor = sourceProto.constructor;\n    var meta = constructor.hasOwnProperty(METADATA_KEY)\n        ? constructor[METADATA_KEY]\n        : Object.defineProperty(constructor, METADATA_KEY, { value: [] })[METADATA_KEY];\n    Array.prototype.push.apply(meta, entries);\n}\nfunction Effect(_a) {\n    var _b = (_a === void 0 ? {} : _a).dispatch, dispatch = _b === void 0 ? true : _b;\n    // Once TS is >= 2.8 replace with <Key extends Extract<keyof T, string>>\n    // for propertyName.\n    return function (target, propertyName) {\n        var metadata = { propertyName: propertyName, dispatch: dispatch };\n        setEffectMetadataEntries(target, [metadata]);\n    };\n}\nfunction getSourceForInstance(instance) {\n    return Object.getPrototypeOf(instance);\n}\nfunction getSourceMetadata(instance) {\n    return compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n}\nfunction getEffectsMetadata(instance) {\n    var metadata = {};\n    try {\n        for (var _a = __values(getSourceMetadata(instance)), _b = _a.next(); !_b.done; _b = _a.next()) {\n            var _c = _b.value, propertyName = _c.propertyName, dispatch = _c.dispatch;\n            metadata[propertyName] = { dispatch: dispatch };\n        }\n    }\n    catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n    }\n    finally {\n        try {\n            if (_b && !_b.done && (_d = _a.return))\n                _d.call(_a);\n        }\n        finally {\n            if (e_1)\n                throw e_1.error;\n        }\n    }\n    return metadata;\n    var e_1, _d;\n}\nvar onRunEffectsKey = 'ngrxOnRunEffects';\nfunction isOnRunEffects(sourceInstance) {\n    var source = getSourceForInstance(sourceInstance);\n    return (onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function');\n}\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m)\n        return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n            ar.push(r.value);\n    }\n    catch (error) {\n        e = { error: error };\n    }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"]))\n                m.call(i);\n        }\n        finally {\n            if (e)\n                throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = (undefined && undefined.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++)\n        ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nfunction mergeEffects(sourceInstance) {\n    var sourceName = getSourceForInstance(sourceInstance).constructor.name;\n    var observables = getSourceMetadata(sourceInstance).map(function (_a) {\n        var propertyName = _a.propertyName, dispatch = _a.dispatch;\n        var observable = typeof sourceInstance[propertyName] === 'function'\n            ? sourceInstance[propertyName]()\n            : sourceInstance[propertyName];\n        if (dispatch === false) {\n            return observable.pipe(ignoreElements());\n        }\n        var materialized$ = observable.pipe(materialize());\n        return materialized$.pipe(map(function (notification) {\n            return ({\n                effect: sourceInstance[propertyName],\n                notification: notification,\n                propertyName: propertyName,\n                sourceName: sourceName,\n                sourceInstance: sourceInstance,\n            });\n        }));\n    });\n    return merge.apply(void 0, __spread(observables));\n}\nfunction resolveEffectSource(sourceInstance) {\n    var mergedEffects$ = mergeEffects(sourceInstance);\n    if (isOnRunEffects(sourceInstance)) {\n        return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n    return mergedEffects$;\n}\nvar __extends = (undefined && undefined.__extends) || /*@__PURE__*/ (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __read$1 = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m)\n        return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n            ar.push(r.value);\n    }\n    catch (error) {\n        e = { error: error };\n    }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"]))\n                m.call(i);\n        }\n        finally {\n            if (e)\n                throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread$1 = (undefined && undefined.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++)\n        ar = ar.concat(__read$1(arguments[i]));\n    return ar;\n};\nvar Actions = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(Actions, _super);\n    function Actions(source) {\n        var _this = _super.call(this) || this;\n        if (source) {\n            _this.source = source;\n        }\n        return _this;\n    }\n    Actions.prototype.lift = function (operator) {\n        var observable = new Actions();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * @deprecated from 6.1.0. Use the pipeable `ofType` operator instead.\n     */\n    /**\n       * @deprecated from 6.1.0. Use the pipeable `ofType` operator instead.\n       */\n    Actions.prototype.ofType = /**\n       * @deprecated from 6.1.0. Use the pipeable `ofType` operator instead.\n       */\n        function () {\n            var allowedTypes = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                allowedTypes[_i] = arguments[_i];\n            }\n            return ofType.apply(void 0, __spread$1(allowedTypes))(this);\n        };\n    return Actions;\n}(Observable));\nfunction ofType() {\n    var allowedTypes = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        allowedTypes[_i] = arguments[_i];\n    }\n    return filter(function (action) {\n        return allowedTypes.some(function (type) { return type === action.type; });\n    });\n}\nfunction verifyOutput(output, reporter) {\n    reportErrorThrown(output, reporter);\n    reportInvalidActions(output, reporter);\n}\nfunction reportErrorThrown(output, reporter) {\n    if (output.notification.kind === 'E') {\n        reporter.handleError(output.notification.error);\n    }\n}\nfunction reportInvalidActions(output, reporter) {\n    if (output.notification.kind === 'N') {\n        var action = output.notification.value;\n        var isInvalidAction = !isAction(action);\n        if (isInvalidAction) {\n            reporter.handleError(new Error(\"Effect \" + getEffectName(output) + \" dispatched an invalid action: \" + stringify(action)));\n        }\n    }\n}\nfunction isAction(action) {\n    return action && action.type && typeof action.type === 'string';\n}\nfunction getEffectName(_a) {\n    var propertyName = _a.propertyName, sourceInstance = _a.sourceInstance, sourceName = _a.sourceName;\n    var isMethod = typeof sourceInstance[propertyName] === 'function';\n    return \"\\\"\" + sourceName + \".\" + propertyName + (isMethod ? '()' : '') + \"\\\"\";\n}\nfunction stringify(action) {\n    try {\n        return JSON.stringify(action);\n    }\n    catch (_a) {\n        return action;\n    }\n}\nvar __extends$1 = (undefined && undefined.__extends) || /*@__PURE__*/ (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar EffectSources = /** @class */ (function (_super) {\n    __extends$1(EffectSources, _super);\n    function EffectSources(errorHandler) {\n        var _this = _super.call(this) || this;\n        _this.errorHandler = errorHandler;\n        return _this;\n    }\n    EffectSources.prototype.addEffects = function (effectSourceInstance) {\n        this.next(effectSourceInstance);\n    };\n    /**\n     * @internal\n     */\n    /**\n       * @internal\n       */\n    EffectSources.prototype.toActions = /**\n       * @internal\n       */\n        function () {\n            var _this = this;\n            return this.pipe(groupBy(getSourceForInstance), mergeMap(function (source$) {\n                return source$.pipe(exhaustMap(resolveEffectSource), map(function (output) {\n                    verifyOutput(output, _this.errorHandler);\n                    return output.notification;\n                }), filter(function (notification) {\n                    return notification.kind === 'N';\n                }), dematerialize());\n            }));\n        };\n    return EffectSources;\n}(Subject));\nvar IMMEDIATE_EFFECTS = /*@__PURE__*/ new InjectionToken('ngrx/effects: Immediate Effects');\nvar ROOT_EFFECTS = /*@__PURE__*/ new InjectionToken('ngrx/effects: Root Effects');\nvar FEATURE_EFFECTS = /*@__PURE__*/ new InjectionToken('ngrx/effects: Feature Effects');\nvar EffectsRunner = /** @class */ /*@__PURE__*/ (function () {\n    function EffectsRunner(effectSources, store) {\n        this.effectSources = effectSources;\n        this.store = store;\n        this.effectsSubscription = null;\n    }\n    EffectsRunner.prototype.start = function () {\n        if (!this.effectsSubscription) {\n            this.effectsSubscription = this.effectSources\n                .toActions()\n                .subscribe(this.store);\n        }\n    };\n    EffectsRunner.prototype.ngOnDestroy = function () {\n        if (this.effectsSubscription) {\n            this.effectsSubscription.unsubscribe();\n            this.effectsSubscription = null;\n        }\n    };\n    return EffectsRunner;\n}());\nvar ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nvar EffectsRootModule = /** @class */ /*@__PURE__*/ (function () {\n    function EffectsRootModule(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule) {\n        this.sources = sources;\n        runner.start();\n        rootEffects.forEach(function (effectSourceInstance) {\n            return sources.addEffects(effectSourceInstance);\n        });\n        store.dispatch({ type: ROOT_EFFECTS_INIT });\n    }\n    EffectsRootModule.prototype.addEffects = function (effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n    };\n    return EffectsRootModule;\n}());\nvar EffectsFeatureModule = /** @class */ /*@__PURE__*/ (function () {\n    function EffectsFeatureModule(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n        this.root = root;\n        effectSourceGroups.forEach(function (group) {\n            return group.forEach(function (effectSourceInstance) {\n                return root.addEffects(effectSourceInstance);\n            });\n        });\n    }\n    return EffectsFeatureModule;\n}());\nvar EffectsModule = /** @class */ /*@__PURE__*/ (function () {\n    function EffectsModule() {\n    }\n    EffectsModule.forFeature = function (featureEffects) {\n        return {\n            ngModule: EffectsFeatureModule,\n            providers: [\n                featureEffects,\n                {\n                    provide: FEATURE_EFFECTS,\n                    multi: true,\n                    deps: featureEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    };\n    EffectsModule.forRoot = function (rootEffects) {\n        return {\n            ngModule: EffectsRootModule,\n            providers: [\n                EffectsRunner,\n                EffectSources,\n                Actions,\n                rootEffects,\n                {\n                    provide: ROOT_EFFECTS,\n                    deps: rootEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    };\n    return EffectsModule;\n}());\nfunction createSourceInstances() {\n    var instances = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        instances[_i] = arguments[_i];\n    }\n    return instances;\n}\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { EffectsFeatureModule as ɵngrx_modules_effects_effects_c, createSourceInstances as ɵngrx_modules_effects_effects_a, EffectsRootModule as ɵngrx_modules_effects_effects_b, EffectsRunner as ɵngrx_modules_effects_effects_f, FEATURE_EFFECTS as ɵngrx_modules_effects_effects_e, ROOT_EFFECTS as ɵngrx_modules_effects_effects_d, Effect, getEffectsMetadata, mergeEffects, Actions, ofType, EffectsModule, EffectSources, ROOT_EFFECTS_INIT };\n//# sourceMappingURL=effects.js.map\n",null]}